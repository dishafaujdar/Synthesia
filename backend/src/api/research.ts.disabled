import express from 'express';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { prisma } from '../config/database';
import { CreateResearchRequest, NotFoundError, ValidationError } from '../types/index';
import { queueManager } from '../services/queue-manager';

const router = express.Router();

// Validation schemas
const createResearchSchema = z.object({
  topic: z.string().min(3, 'Topic must be at least 3 characters').max(200, 'Topic too long'),
  priority: z.enum(['low', 'normal', 'high']).default('normal'),
});

const paginationSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(10),
});

// Validation middleware
const validateRequest = (schema: { body?: z.ZodSchema, query?: z.ZodSchema }) => {
  return (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      if (schema.body) {
        req.body = schema.body.parse(req.body);
      }
      if (schema.query) {
        req.query = schema.query.parse(req.query);
      }
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: error.errors
        });
      }
      next(error);
    }
  };
};

// Safe queue manager getter to avoid circular imports
const getQueueManager = async () => {
  try {
    const { queueManager } = await import('@/jobs/queue');
    if (!queueManager) {
      console.warn('Queue manager not available');
      return null;
    }
    return queueManager;
  } catch (error) {
    console.error('Failed to import queue manager:', error);
    return null;
  }
};

// Create new research request
router.post(
  '/',
  validateRequest({ body: createResearchSchema }),
  async (req, res, next) => {
    try {
      const { topic, priority } = req.body as CreateResearchRequest;
      const correlationId = uuidv4();
      const userId = req.user?.id;

      console.log(`Creating research request for topic: "${topic}"`);

      // Create database record first
      const requestData: any = {
        topic,
        priority: (priority as 'low' | 'normal' | 'high') || 'normal',
        correlationId,
        status: 'PENDING',
      };
      
      if (userId) {
        requestData.userId = userId;
      }
      
      let request;
      try {
        request = await db.researchRequest.create({
          data: requestData,
        });
        console.log(`Research request created with ID: ${request.id}`);
      } catch (dbError) {
        console.error('Database error, falling back to mock mode:', dbError);
        // Create mock request for development
        request = {
          id: `mock-${Date.now()}`,
          ...requestData,
          createdAt: new Date(),
          updatedAt: new Date(),
          progress: 0,
        };
      }

      // Get queue manager safely
      console.log('Getting queue manager...');
      const queueManager = await getQueueManager();
      
      if (!queueManager) {
        console.warn('Queue manager not available - research will not be processed');
        return res.status(201).json({
          id: request.id,
          topic: request.topic,
          status: 'PENDING',
          priority: request.priority,
          progress: request.progress,
          correlationId: request.correlationId,
          createdAt: request.createdAt,
          updatedAt: request.updatedAt,
          warning: 'Queue not available - research will not be processed'
        });
      }

      // Create job data
      const jobData: ResearchJobData = {
        id: request.id,
        topic: request.topic,
        priority: (priority as 'low' | 'normal' | 'high') || 'normal',
        userId: userId || '',
        correlationId: request.correlationId,
      };

      console.log('Adding job to queue:', jobData);

      // Add to queue with error handling
      let job;
      try {
        job = await queueManager.addJob(jobData, priority as 'low' | 'normal' | 'high');
        console.log(`Job added successfully with ID: ${job.id}`);
        
        // Update request with job ID if using real database
        if (typeof request.id === 'string' && !request.id.startsWith('mock-')) {
          try {
            await db.researchRequest.update({
              where: { id: request.id },
              data: { jobId: job.id.toString() },
            });
          } catch (updateError) {
            console.warn('Failed to update request with job ID:', updateError);
          }
        }
      } catch (queueError) {
        console.error('Failed to add job to queue:', queueError);
        // Still return success but with warning
        return res.status(201).json({
          id: request.id,
          topic: request.topic,
          status: 'PENDING',
          priority: request.priority,
          progress: request.progress,
          correlationId: request.correlationId,
          createdAt: request.createdAt,
          updatedAt: request.updatedAt,
          warning: 'Job queuing failed - research may not be processed'
        });
      }

      res.status(201).json({
        id: request.id,
        topic: request.topic,
        status: request.status,
        priority: request.priority,
        progress: request.progress,
        correlationId: request.correlationId,
        createdAt: request.createdAt,
        updatedAt: request.updatedAt,
        jobId: job?.id
      });
    } catch (error) {
      console.error('Error in research POST route:', error);
      next(error);
    }
  }
);

// Get all research requests
router.get(
  '/',
  validateRequest({ query: paginationSchema }),
  async (req, res, next) => {
    try {
      const { page, limit } = paginationSchema.parse(req.query);
      const userId = req.user?.id;

      const where = userId ? { userId } : {};
      const skip = (page - 1) * limit;

      console.log(`Fetching research requests: page ${page}, limit ${limit}`);

      try {
        const [requests, total] = await Promise.all([
          db.researchRequest.findMany({
            where,
            skip,
            take: limit,
            orderBy: { createdAt: 'desc' },
            include: {
              results: {
                include: {
                  articles: {
                    select: {
                      id: true,
                      title: true,
                      url: true,
                      relevanceScore: true,
                    },
                  },
                },
              },
              _count: {
                select: { taskLogs: true },
              },
            },
          }),
          db.researchRequest.count({ where }),
        ]);

        console.log(`Found ${requests.length} research requests`);

        res.json({
          data: requests.map((request: any) => ({
            ...request,
            logCount: request._count.taskLogs,
          })),
          pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit),
          },
        });
      } catch (dbError) {
        console.warn('Database not available, returning mock data:', dbError);
        
        const mockRequests = [
          {
            id: 'mock-ai-research',
            topic: 'Artificial Intelligence in Healthcare',
            status: 'COMPLETED',
            priority: 'normal',
            progress: 100,
            correlationId: 'mock-corr-ai',
            createdAt: new Date('2024-09-20T10:00:00Z'),
            updatedAt: new Date('2024-09-20T10:05:00Z'),
            completedAt: new Date('2024-09-20T10:05:00Z'),
            logCount: 5,
            results: {
              totalArticles: 8,
              keywords: ['AI', 'healthcare', 'machine learning', 'diagnostics'],
              confidence: 0.87,
            },
          },
          {
            id: 'mock-climate-research',
            topic: 'Climate Change Renewable Energy',
            status: 'IN_PROGRESS',
            priority: 'high',
            progress: 65,
            correlationId: 'mock-corr-climate',
            createdAt: new Date('2024-09-20T11:00:00Z'),
            updatedAt: new Date('2024-09-20T11:03:00Z'),
            completedAt: null,
            logCount: 3,
            results: null,
          },
        ];

        res.json({
          data: mockRequests,
          pagination: {
            page: 1,
            limit: 10,
            total: 2,
            pages: 1,
          },
          mock: true
        });
      }
    } catch (error) {
      console.error('Error in research GET route:', error);
      next(error);
    }
  }
);

// Get specific research request
router.get('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    console.log(`Fetching research request: ${id}`);

    const where = userId ? { id, userId } : { id };

    try {
      const request = await db.researchRequest.findUnique({
        where,
        include: {
          results: {
            include: {
              articles: true,
            },
          },
          taskLogs: {
            orderBy: { timestamp: 'desc' },
            take: 50,
          },
        },
      });

      if (!request) {
        throw new NotFoundError('Research request');
      }

      res.json(request);
    } catch (dbError) {
      console.warn('Database not available, returning mock research details:', dbError);
      
      const mockData: Record<string, any> = {
        'mock-ai-research': {
          id: id,
          topic: 'Artificial Intelligence in Healthcare',
          status: 'COMPLETED',
          priority: 'normal',
          progress: 100,
          correlationId: 'mock-corr-ai',
          createdAt: new Date('2024-09-20T10:00:00Z'),
          updatedAt: new Date('2024-09-20T10:05:00Z'),
          completedAt: new Date('2024-09-20T10:05:00Z'),
          results: {
            id: `mock-result-${id}`,
            summary: 'AI in healthcare shows significant promise for improving diagnostics, treatment personalization, and operational efficiency. Machine learning algorithms are being deployed across radiology, pathology, and drug discovery.',
            keyInsights: [
              'AI diagnostic tools achieve 95%+ accuracy in medical imaging',
              'Machine learning reduces drug discovery timelines by 30-50%',
              'Personalized medicine through AI improves treatment outcomes',
              'Regulatory frameworks are rapidly evolving to accommodate AI'
            ],
            keywords: ['AI', 'healthcare', 'machine learning', 'diagnostics', 'personalized medicine'],
            totalArticles: 8,
            confidence: 0.87,
            processingTime: 4200,
            articles: [
              {
                id: 'mock-article-1',
                title: 'AI-Powered Diagnostic Tools Transform Medical Imaging',
                url: 'https://example.com/ai-medical-imaging',
                content: 'Artificial intelligence is revolutionizing medical imaging with diagnostic accuracy rates exceeding traditional methods.',
                source: 'Medical AI Journal',
                relevanceScore: 0.94,
                publishedDate: new Date('2024-09-15T00:00:00Z'),
              },
              {
                id: 'mock-article-2',
                title: 'Machine Learning Accelerates Drug Discovery Pipeline',
                url: 'https://example.com/ml-drug-discovery',
                content: 'Machine learning algorithms are reducing the time and cost of drug discovery by identifying promising compounds faster.',
                source: 'Pharmaceutical Research Today',
                relevanceScore: 0.91,
                publishedDate: new Date('2024-09-18T00:00:00Z'),
              }
            ]
          },
          taskLogs: [
            {
              id: 'mock-log-1',
              level: 'INFO',
              message: 'Research completed successfully',
              timestamp: new Date('2024-09-20T10:05:00Z'),
            },
            {
              id: 'mock-log-2',
              level: 'INFO',
              message: 'Analyzing medical research papers',
              timestamp: new Date('2024-09-20T10:04:30Z'),
            },
            {
              id: 'mock-log-3',
              level: 'INFO',
              message: 'Extracting insights from healthcare databases',
              timestamp: new Date('2024-09-20T10:03:45Z'),
            }
          ]
        }
      };

      const mockRequest = mockData[id] || {
        id: id,
        topic: 'Research Topic',
        status: 'COMPLETED',
        priority: 'normal',
        progress: 100,
        correlationId: `mock-corr-${id}`,
        createdAt: new Date(),
        updatedAt: new Date(),
        completedAt: new Date(),
        results: {
          id: `mock-result-${id}`,
          summary: 'This is a mock research result for development purposes.',
          keyInsights: ['Mock insight 1', 'Mock insight 2'],
          keywords: ['research', 'development', 'mock'],
          totalArticles: 3,
          confidence: 0.75,
          processingTime: 2000,
          articles: []
        },
        taskLogs: []
      };

      res.json({ ...mockRequest, mock: true });
    }
  } catch (error) {
    console.error('Error in research GET by ID route:', error);
    next(error);
  }
});

// Get research request status
router.get('/:id/status', async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    const where = userId ? { id, userId } : { id };

    try {
      const request = await db.researchRequest.findUnique({
        where,
        select: {
          id: true,
          status: true,
          progress: true,
          error: true,
          updatedAt: true,
        },
      });

      if (!request) {
        throw new NotFoundError('Research request');
      }

      res.json(request);
    } catch (dbError) {
      console.warn('Database not available for status check:', dbError);
      res.json({
        id,
        status: 'COMPLETED',
        progress: 100,
        error: null,
        updatedAt: new Date(),
        mock: true
      });
    }
  } catch (error) {
    console.error('Error in research status route:', error);
    next(error);
  }
});

// Delete research request
router.delete('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;
    const { force } = req.query;

    console.log(`Deleting research request: ${id}`);

    const where = userId ? { id, userId } : { id };

    try {
      const request = await db.researchRequest.findUnique({ 
        where,
        include: {
          results: true
        }
      });

      if (!request) {
        throw new NotFoundError('Research request');
      }

      if (request.status === 'IN_PROGRESS' && !force) {
        throw new ValidationError('Cannot delete request that is currently processing. Use force=true to override.');
      }

      // Cancel job if it exists and queue is available
      if (request.jobId) {
        try {
          const queueManager = await getQueueManager();
          if (queueManager && typeof queueManager.getJob === 'function') {
            const job = await queueManager.getJob(request.jobId);
            if (job && typeof (job as any).remove === 'function') {
              await (job as any).remove();
              console.log(`Cancelled job: ${request.jobId}`);
            } else {
              console.warn(`Job ${request.jobId} not found or cannot be removed`);
            }
          }
        } catch (jobError) {
          console.warn(`Failed to remove job ${request.jobId}:`, jobError);
        }
      }

      // Delete related records in transaction
      await db.$transaction(async (tx) => {
        await tx.taskLog.deleteMany({
          where: { researchRequestId: id }
        });

        if (request.results && request.results.length > 0) {
          const resultIds = request.results.map(r => r.id);
          
          await tx.article.deleteMany({
            where: { researchResultId: { in: resultIds } }
          });
          
          await tx.researchResult.deleteMany({
            where: { id: { in: resultIds } }
          });
        }

        await tx.researchRequest.delete({
          where: { id }
        });
      });

      res.json({ message: 'Research request deleted successfully' });
    } catch (dbError) {
      console.warn('Database not available for deletion:', dbError);
      res.json({ message: 'Research request deleted successfully (mock mode)' });
    }
  } catch (error) {
    console.error('Error in research DELETE route:', error);
    next(error);
  }
});

export default router;